/**
 * @fileoverview A middleware for CSRF prevention using the
 * "double submit cookie" pattern as described on
 * [OWASP CSRF Prevention Cheat Sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet)
 *
 * This middleware extends the request object by adding two methods:
 * - `getCsrfToken()` returns the CSRF token value for the current request,
 * creating and setting it as a cookie if necessary
 * - `rotateCsrfToken()` creates a new CSRF token and stores it in a cookie.
 *
 * Use `getCsrfToken()` of the request object to add the token value in
 * all forms generated by the application, and make sure the name of the form
 * input is configured accordingly (defaults to "csrftoken"). Both the
 * POST parameter and the cookie value are compared, and in case of a
 * mismatch this middleware returns a 403 "Forbidden" response.
 *
 * For non-POST requests this middleware accepts the token sent as query
 * parameter or custom header field.
 *
 * ### Configuration options:
 *
 * `app.csrf()` accepts an object as parameter containing the following
 * properties (default values in brackets):
 *
 * - `tokenLength`: The length of the CSRF token (32)
 * - `cookieName`: The name of the CSRF cookie ("csrftoken")
 * - `cookieHttpOnly`: The value of the CSRF cookie's httpOnly flag (true)
 * - `cookieSecure`: The value of the CSRF cookie's secure flag (false)
 * - `postParamName`: The name of the `req.postParams` property containing the CSRF token ("csrftoken")
 * - `queryParamName`: The name of the `req.queryParams` property containing the CSRF token ("csrftoken")
 * - `headerName`: The name of the request header field containing the CSRF token ("x-csrf-token")
 * - `safeMethods`: An array containing request method names that are
 * considered safe, so no token validation is done (["GET", "HEAD", "OPTIONS", "TRACE"])
 *
 * @example
 * app.configure("csrf");
 * app.csrf({
 *     "tokenLength": 64,
 *     "cookieName": "csrf-token",
 *     "cookieSecure": true
 * });
 */
var log = require("ringo/logging").getLogger(module.id);

var {SecureRandom} = java.security;
var {ByteArray} = require("binary");
var response = require("ringo/jsgi/response");
var {setCookie} = require("ringo/utils/http");

var TOKEN_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
var TOKEN_LENGTH = 32;

var RANDOM_PRNG = "SHA1PRNG";
var RANDOM_PROVIDER = "SUN";

var SAFE_METHODS = ["GET", "HEAD", "OPTIONS", "TRACE"];
var COOKIE_NAME = "csrftoken";
var COOKIE_HTTPONLY = true;
var COOKIE_SECURE = false;
var NAME_POST = "csrftoken";
var NAME_QUERY = "csrftoken";
var NAME_HEADER = "x-csrf-token";

/**
 * The random generator
 * @type {java.security.SecureRandom}
 */
var random = SecureRandom.getInstance(RANDOM_PRNG, RANDOM_PROVIDER);

/**
 * Returns a random string with the given length
 * @param {Number} len The length of the string to return
 * @returns {String} The random string
 */
var generateCsrfToken = function(len) {
    var buf = [];
    for (let i=0; i<len; i+=1) {
        buf.push(TOKEN_CHARS[random.nextInt(TOKEN_CHARS.length)]);
    }
    return buf.join("");
};

/**
 * Returns true if the tokens passed as argument are equal
 * @param {String} token The token
 * @param {String} cookieToken The token cookie value
 * @returns {Boolean} True if the tokens are equal, false otherwise
 */
var isValidCsrfToken = function(token, cookieToken) {
    if (typeof(token) !== "string" || typeof(cookieToken) !== "string") {
        log.debug("Missing CSRF token(s)");
        return false;
    }
    return equals(token.toByteArray(), cookieToken.toByteArray());
};

/**
 * Compares the two byte arrays in constant time to prevent timing attacks
 * @param {ByteArray} bytesA The byte array to compare
 * @param {ByteArray} bytesB The byte array to compare to
 * @returns {Boolean} True if the byte arrays are equal, false otherwise
 */
var equals = function(bytesA, bytesB) {
    var diff = bytesA.length ^ bytesB.length;
    for (let i=0; i<bytesA.length && i<bytesB.length; i+=1) {
        diff |= bytesA[i] ^ bytesB[i];
    }
    return diff == 0;
};

/**
* Stick middleware factory for CSRF prevention
* @param {Function} next the wrapped middleware chain
* @param {Object} app the Stick Application object
* @returns {Function} a JSGI middleware function
*/
exports.middleware = function csrf(next, app) {

    var config = {
        "tokenLength": TOKEN_LENGTH,
        "safeMethods": SAFE_METHODS,
        "cookieName": COOKIE_NAME,
        "cookieHttpOnly": COOKIE_HTTPONLY,
        "cookieSecure": COOKIE_SECURE,
        "postParamName": NAME_POST,
        "queryParamName": NAME_QUERY,
        "headerName": NAME_HEADER
    };

    /**
     * Configures the CSRF middleware
     * @param {Object} conf The configuration options
     */
    app.csrf = function(conf) {
        for each (let [key, value] in conf) {
            if (config.hasOwnProperty(key)) {
                config[key] = value;
            } else {
                throw new Error("Unknown config option '" + key + '"');
            }
        }
    };

    /**
     * The middleware function
     */
    return function csrf(req) {
        var token = req.cookies[config.cookieName] || null;
        var doSetCookie = false;

        Object.defineProperties(req, {
            /**
             * Returns the current token cookie value. If none exists this
             * method creates a new CSRF token and stores it as cookie.
             */
            "getCsrfToken": {
                "value": function() {
                    if (!token) {
                        token = generateCsrfToken(config.tokenLength);
                        doSetCookie = true;
                    }
                    return token;
                }
            },
            /**
             * Creates a new CRSF token and stores it as cookie. This
             * method should be called after login for security reasons.
             */
            "rotateCsrfToken": {
                "value": function() {
                    token = generateCsrfToken(config.tokenLength);
                    doSetCookie = true;
                    return token;
                }
            }
        });

        var res;
        // ignore non-modifying request methods
        if (config.safeMethods.indexOf(req.method) > -1) {
            res = next(req, app);
        } else {
            // validate token
            var submittedToken = req.postParams[config.queryParamName] ||
                    req.queryParams[config.postParamName] ||
                    req.headers[config.headerName];
            if (!isValidCsrfToken(submittedToken, token)) {
                return response.forbidden();
            }
            res = next(req, app);
        }
        if (doSetCookie === true) {
            res.headers["Set-Cookie"] = setCookie(config.cookieName, token, -1, {
                "httpOnly": config.cookieHttpOnly,
                "secure": config.cookieSecure
            });
            res.headers["Vary"] = "Cookie";
        }
        return res;
    };
};