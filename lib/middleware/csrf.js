/**
 * @fileoverview A middleware for CSRF prevention using the
 * synchronizer token pattern as described on
 * [OWASP CSRF Prevention Cheat Sheet](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29_Prevention_Cheat_Sheet)
 *
 * This middleware extends the request object by adding two methods:
 * - `getCsrfToken()` returns the CSRF token value for the current request,
 * creating and storing it in the current session if necessary
 * - `rotateCsrfToken()` creates a new CSRF token and stores it in the current session
 *
 * Use `getCsrfToken()` of the request object to add the token value in
 * all forms generated by the application, and make sure the name of the form
 * input is configured accordingly (defaults to "csrftoken"). The POST parameter
 * and the token value stored in the current session are compared, and in case of a
 * mismatch this middleware returns a 403 "Forbidden" response.
 *
 * For non-POST requests this middleware accepts the token sent as query
 * parameter or custom header field.
 *
 * ### Configuration options:
 *
 * `app.csrf()` accepts an object as parameter containing the following
 * properties (default values in brackets):
 *
 * - `tokenLength`: The length of the CSRF token (32)
 * - `rotate`: If true tokens are only used once and modified after each validation (false)
 * - `postParamName`: The name of the `req.postParams` property containing the CSRF token ("csrftoken")
 * - `queryParamName`: The name of the `req.queryParams` property containing the CSRF token ("csrftoken")
 * - `headerName`: The name of the request header field containing the CSRF token ("x-csrf-token")
 * - `safeMethods`: An array containing request method names that are
 * considered safe, so no token validation is done (["GET", "HEAD", "OPTIONS", "TRACE"])
 *
 * @example
 * app.configure("csrf");
 * app.csrf({
 *     "tokenLength": 64,
 *     "rotate": true,
 *     "postParamName": "ctoken",
 *     "queryParamName": "ctoken",
 *     "headerName": "x-xsrf-token"
 * });
 */
var log = require("ringo/logging").getLogger(module.id);

var {SecureRandom} = java.security;
var {ByteArray} = require("binary");
var response = require("ringo/jsgi/response");

var TOKEN_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
var TOKEN_LENGTH = 32;

var RANDOM_PRNG = "SHA1PRNG";
var RANDOM_PROVIDER = "SUN";

var SAFE_METHODS = ["GET", "HEAD", "OPTIONS", "TRACE"];
var NAME_POST = "csrftoken";
var NAME_QUERY = "csrftoken";
var NAME_HEADER = "x-csrf-token";

/**
 * The random generator
 * @type {java.security.SecureRandom}
 */
var random = SecureRandom.getInstance(RANDOM_PRNG, RANDOM_PROVIDER);

/**
 * Returns a random string with the given length
 * @param {Number} len The length of the string to return
 * @returns {String} The random string
 */
var generateCsrfToken = function(len) {
    var buf = [];
    for (let i=0; i<len; i+=1) {
        buf.push(TOKEN_CHARS[random.nextInt(TOKEN_CHARS.length)]);
    }
    return buf.join("");
};

/**
 * Returns true if the tokens passed as argument are equal
 * @param {String} token The token
 * @param {String} sessionToken The session token value
 * @returns {Boolean} True if the tokens are equal, false otherwise
 */
var isValidCsrfToken = function(token, sessionToken) {
    if (typeof(token) !== "string" || typeof(sessionToken) !== "string") {
        log.debug("Missing CSRF token(s)");
        return false;
    }
    return equals(token.toByteArray(), sessionToken.toByteArray());
};

/**
 * Compares the two byte arrays in constant time to prevent timing attacks
 * @param {ByteArray} bytesA The byte array to compare
 * @param {ByteArray} bytesB The byte array to compare to
 * @returns {Boolean} True if the byte arrays are equal, false otherwise
 */
var equals = function(bytesA, bytesB) {
    var diff = bytesA.length ^ bytesB.length;
    for (let i=0; i<bytesA.length && i<bytesB.length; i+=1) {
        diff |= bytesA[i] ^ bytesB[i];
    }
    return diff == 0;
};

/**
* Stick middleware factory for CSRF prevention
* @param {Function} next the wrapped middleware chain
* @param {Object} app the Stick Application object
* @returns {Function} a JSGI middleware function
*/
exports.middleware = function csrf(next, app) {

    var config = {
        "tokenLength": TOKEN_LENGTH,
        "rotate": false,
        "safeMethods": SAFE_METHODS,
        "postParamName": NAME_POST,
        "queryParamName": NAME_QUERY,
        "headerName": NAME_HEADER
    };

    /**
     * Configures the CSRF middleware
     * @param {Object} conf The configuration options
     */
    app.csrf = function(conf) {
        for each (let [key, value] in Iterator(conf)) {
            if (config.hasOwnProperty(key)) {
                config[key] = value;
            } else {
                throw new Error("Unknown config option '" + key + '"');
            }
        }
    };

    /**
     * The middleware function
     */
    return function csrf(req) {
        var sessionData = req.session.data;

        Object.defineProperties(req, {
            /**
             * Returns the current token value. If none exists this
             * method creates a new CSRF token and stores it in the session
             */
            "getCsrfToken": {
                "value": function() {
                    if (!sessionData.csrfToken) {
                        sessionData.csrfToken = generateCsrfToken(config.tokenLength);
                    }
                    return sessionData.csrfToken;
                }
            },
            /**
             * Creates a new CRSF token and stores it in the session. This
             * method should be called after login for security reasons.
             */
            "rotateCsrfToken": {
                "value": function() {
                    return sessionData.csrfToken = generateCsrfToken(config.tokenLength);
                }
            }
        });

        var res;
        // ignore non-modifying methods
        if (config.safeMethods.indexOf(req.method) > -1) {
            res = next(req, app);
        } else {
            // validate token
            var submittedToken = req.queryParams[config.queryParamName] ||
                    req.postParams[config.postParamName] ||
                    req.headers[config.headerName];

            if (!isValidCsrfToken(submittedToken, sessionData.csrfToken)) {
                return response.forbidden();
            }
            if (config.rotate === true) {
                sessionData.csrfToken = generateCsrfToken(config.tokenLength);
            }
            res = next(req, app);
        }
        return res;
    };
};